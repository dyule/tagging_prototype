// Generated by CoffeeScript 1.9.3
(function() {
  var _findMatching, _findPrefix, _findWithoutPrefix, _removeFromNode, exports, objects, tags,
    hasProp = {}.hasOwnProperty;

  exports = {};

  window.tagging = exports;

  objects = [
    {
      name: "Object 1",
      tags: ["tag1", "tag2"]
    }, {
      name: "Object 2",
      tags: ["tag3"]
    }
  ];

  tags = {
    't': {
      'a': {
        'g': {
          1: {
            objects: [objects[0]]
          },
          2: {
            objects: [objects[0]]
          },
          3: {
            objects: [objects[1]]
          }
        }
      }
    }
  };

  exports.addObject = function(obj) {
    var i, len, myTags, tag;
    if (!obj.tags) {
      obj.tags = [];
    } else {
      myTags = obj.tags;
      obj.tags = [];
      for (i = 0, len = myTags.length; i < len; i++) {
        tag = myTags[i];
        tagging.addTag(obj, tag);
      }
    }
    if (!obj.name) {
      obj.name = "";
    }
    return objects.push(obj);
  };

  exports.forObjectsAndTags = function(objFunc, subTagFunc, relatedTagFunc, tagList) {
    var childTag, childTags, i, j, k, l, len, len1, len2, len3, len4, len5, m, n, navTag, node, obj, objList, ref, relatedTags, rootTag, subTags, tag, tagIndex, toAdd;
    tagIndex = 0;
    subTags = {};
    relatedTags = {};
    objList = objects;
    if (tagList.length > 0) {
      for (i = 0, len = tagList.length; i < len; i++) {
        navTag = tagList[i];
        childTags = _findWithoutPrefix(navTag + "/", 0, tags);
        subTagFunc(navTag, childTags);
        for (j = 0, len1 = childTags.length; j < len1; j++) {
          childTag = childTags[j];
          subTags[childTag] = true;
        }
      }
      rootTag = tagList[0];
      node = tags;
      while (tagIndex < rootTag.length) {
        if (node[rootTag[tagIndex]]) {
          node = node[rootTag[tagIndex]];
          tagIndex += 1;
        } else {
          return;
        }
      }
      if (node.objects) {
        objList = node.objects;
      } else {
        objList = [];
      }
    } else {
      childTags = _findMatching("", tags);
      subTagFunc("<root>", childTags);
      for (k = 0, len2 = childTags.length; k < len2; k++) {
        childTag = childTags[k];
        subTags[childTag] = true;
      }
    }
    for (l = 0, len3 = objList.length; l < len3; l++) {
      obj = objList[l];
      toAdd = true;
      for (m = 0, len4 = tagList.length; m < len4; m++) {
        tag = tagList[m];
        if (obj.tags.indexOf(tag) === -1) {
          toAdd = false;
        }
      }
      if (toAdd) {
        objFunc(obj);
        ref = obj.tags;
        for (n = 0, len5 = ref.length; n < len5; n++) {
          tag = ref[n];
          if (tagList.indexOf(tag) === -1 && !subTags[tag]) {
            relatedTags[tag] = true;
          }
        }
      }
    }
    for (tag in relatedTags) {
      if (!hasProp.call(relatedTags, tag)) continue;
      relatedTagFunc(tag);
    }
  };

  exports.objectsInTag = function(tag) {
    var ObjTag, i, j, len, len1, obj, ref, results;
    results = [];
    for (i = 0, len = objects.length; i < len; i++) {
      obj = objects[i];
      ref = obj.tags;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        ObjTag = ref[j];
        if (objTag === tag) {
          results.push(obj);
          break;
        }
      }
    }
    return results;
  };

  exports.addTag = function(obj, tag) {
    var ch, i, len, node;
    obj.tags.push(tag);
    node = tags;
    for (i = 0, len = tag.length; i < len; i++) {
      ch = tag[i];
      if (!node[ch]) {
        node[ch] = {};
      }
      node = node[ch];
    }
    if (!node.objects) {
      node.objects = [];
    }
    return node.objects.push(obj);
  };

  exports.removeTag = function(obj, tag) {
    var index;
    index = obj.tags.indexOf(tag);
    if (index > -1) {
      obj.tags.splice(index, 1);
      return _removeFromNode(tag, 0, tags, obj);
    }
  };

  _removeFromNode = function(tag, index, node, obj) {
    var ch, objIndex;
    if (index === tag.length) {
      objIndex = node.objects.indexOf(obj);
      node.objects.splice(objIndex, 1);
      if (node.objects.length === 0) {
        for (ch in node) {
          if (!hasProp.call(node, ch)) continue;
          if (ch !== 'objects') {
            return false;
          }
        }
        return true;
      }
    } else {
      if (_removeFromNode(tag, index + 1, node[tag[index]], obj)) {
        delete node[tag[index]];
        if (!node.count || node.objects.length === 0) {
          for (ch in node) {
            if (!hasProp.call(node, ch)) continue;
            if (ch !== 'objects') {
              return false;
            }
          }
          return true;
        }
      }
    }
    return false;
  };

  _findPrefix = function(stub, index, node) {
    if (!node) {
      return [];
    } else if (index === stub.length) {
      return _findMatching(stub, node);
    } else {
      return _findPrefix(stub, index + 1, node[stub[index]]);
    }
  };

  _findWithoutPrefix = function(stub, index, node) {
    if (!node) {
      return [];
    } else if (index === stub.length) {
      return _findMatching("", node);
    } else {
      return _findWithoutPrefix(stub, index + 1, node[stub[index]]);
    }
  };

  _findMatching = function(stub, node) {
    var ch, results;
    if (!node) {
      return [];
    }
    results = [];
    for (ch in node) {
      if (!hasProp.call(node, ch)) continue;
      if (ch === 'objects') {
        if (node.objects.length > 0) {
          results.push(stub);
        }
      } else if (ch === '/') {
        results.push(stub);
      } else {
        results = results.concat(_findMatching(stub + ch, node[ch]));
      }
    }
    return results;
  };

  exports.matchingTags = function(stub, callback) {
    var results;
    results = _findPrefix(stub, 0, tags);
    return callback(results);
  };

}).call(this);

//# sourceMappingURL=tagging.js.map
